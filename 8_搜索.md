# 搜索



## DFS

***

### 枚举

#### 指数型

```cpp
void calc(int x) {
    if (x > n) {
        for (int i: choose) cout << i << ' ';
        cout << endl;
        return;
    }
    calc(x + 1); // choose
    choose.push_back(x); // not choose
    calc(x + 1);
    choose.pop_back();
};
```

#### 组合型

```cpp
void calc(int x) {
    if (choose.size() > m || choose.size() + n - x + 1 < m)
        return;
    if (x > n) {
        for (int i: choose) cout << i << ' ';
        cout << endl;
        return;
    }
    choose.push_back(x); // not choose
    calc(x + 1);
    choose.pop_back();
    calc(x + 1); // choose
};
```

#### 排列型

```cpp
void calc(int x) {
    if (x > n) {
        for (int i = 1; i <= n; ++ i)
            printf("%d%c", a[i], " \n"[i == n]);
        return;
    }
    for (int i = 1; i <= n; ++ i)
        if (!st[i]) {
            a[x] = i, st[i] = true;
            calc(x + 1);
            a[x] = 0, st[i] = false;
        }
}
```



## BFS

***

### Flood_Fill

可以在线性时间复杂度内, 找到某个点所在的连通块.

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1005, M = N * N;
char g[N][N];
bool st[N][N];
int n, m, cnt;
PII q[M];

void bfs(int x, int y) {
    int hh = 0, tt = 0;
    q[tt] = {x, y};
    st[x][y] = true;
    
    while (hh <= tt) {
        auto [x, y] = q[hh ++];
        for (int i = x - 1; i <= x + 1; ++ i)
            for (int j = y - 1; j <= y + 1; ++ j) {
                if (i == x && j == y) continue;
                if (i < 0 || i >= n || j < 0 || j >= m) continue;
                if (g[i][j] == '.' || st[i][j]) continue;
                
                q[++ tt] = {i, j};
                st[i][j] = true;
            }
    }
}

int main() {
    cin.tie(0)->sync_with_stdio(0);
    
    cin >> n >> m;
    for (int i = 0; i < n; ++ i) cin >> g[i];
    
    for (int i = 0; i < n; ++ i)
        for (int j = 0; j < m; ++ j)
            if (g[i][j] == 'W' && !st[i][j]) {
                bfs(i, j);
                ++ cnt;
            }
    
    cout << cnt << '\n';
}
```

### 最短距离



### 最小步数

