# 基本算法



## 位运算

***

### 快速幂

```cpp
int fpow(int a, int b, int c) {
    int res = 1 % c;
    for (; b; b >>= 1) {
        if (b & 1) res = (long long)res * a % c;
        a = (long long)a * a % c;
    }
    return res;
}
```

### 龟速乘

```cpp
LL mul(LL a, LL b, LL c) {
    LL res = 0;
    for (; b; b >>= 1) {
        if (b & 1) res = (res + a) % c;
        a = (a + a) % c;
    }
    return res;
}
```

### 快速乘

```cpp
ull mul(ull a, ull b, ull p) {
    a %= p, b %= p;
    ull c = (long double)a * b / p;
    ull x = a * b, y = c * p;
    ll res = (ll)(x % p) - (ll)(y % p);
    if (res < 0) res += p;
    return res;
}
```



## 排序算法

***

### 1快速排序

```c++
void q_sort(int l, int r) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = a[l + r >> 1];
    while (i < j) {
        do i ++; while (x > a[i]);
        do j --; while (x < a[j]);
        if (i < j) swap(a[i], a[j]);
    }
    q_sort(l, j), q_sort(j + 1, r); //此处边界不能换为(l,i),(i+1,r) 否则会死循环
}
```


### 2归并排序

```c++
void merge_sort(int l, int r) {
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(l, mid), merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = l;
    while (i <= mid && j <= r)
        if (a[i] < a[j]) b[k ++] = a[i ++];
        else b[k ++] = a[j ++];
    while (i <= mid) b[k ++] = a[i ++];
    while (j <= r) b[k ++] = a[j ++];
    for (int i = l; i <= r; i ++) a[i] = b[i];
}
```



## 二分

***

### 整数二分算法模板

```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质
```

### 1区间[l,r]被划分成[l,mid]和[mid+1,r]时使用

```c++
int bsearch_1(int l, int r) {
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
```

### 2区间[l,r]被划分成[l,mid-1]和[mid,r]时使用

```c++
int bsearch_2(int l, int r) {
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

### 3浮点数二分算法模板

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r) {
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```



## 高精度

***

### 1加法

```c++
vector<int> add(vector<int> &a,vector<int> &b){
    vector<int> c;
    int t=0;//进位
    for(int i=0;i<a.size() || i<b.size();i++){
        if(i<a.size()) t+=a[i];
        if(i<b.size()) t+=b[i];
        c.push_back(t%10);
        t/=10;//进位权重下降
    }
    if(t) c.push_back(1);
    return c;
}
```

### 2减法

```c++
bool cmp(vector<int> &a,vector<int> &b){
    if(a.size()!=b.size()) return a.size()>b.size();
    for(int i=a.size();i>=0;i--)
        if(a[i]!=b[i])
            return a[i]>b[i];
    return true;
}

vector<int> sub(vector<int> &a,vector<int> &b){
    vector<int> c;
    int t=0;//借位
    for(int i=0;i<a.size();i++){
        t=a[i]-t;
        if(i<b.size()) t-=b[i];
        c.push_back((t+10)%10);
        if(t<0) t=1;//t<0 表示借位了
        else t=0;//否则就是没借位
    }
    while(c.size()>1 && c.back()==0) c.pop_back();
    return c;
}
```

### 3乘法

1

```c++
vector<int> mul(vector<int> &a,int &b){
    vector<int> c;
    for(int i=0,t=0;i<a.size() || t;i++){//进位存在或没乘完
        if(i<a.size()) t+=a[i]*b;
        c.push_back(t%10);
        t/=10;
    }
    while(c.size()>1 && c.back()==0) c.pop_back();//去除前导零
    return c;
}
```

2

```c++
// 高精乘高精
vector<int> mul(vector<int> &a, vector<int> &b) {
    vector<int> c;
    c.resize(a.size() + b.size());
    for (int i = 0; i < a.size(); ++ i) {
        int t = 0;
        for (int j = 0; j < b.size(); ++ j) {
            c[i + j] += t + a[i] * b[j];
            t = c[i + j] / 10;
            c[i + j] %= 10;
        }
        c[i + b.size()] = t;
    }
    while (c.size() > 1 && c.back() == 0) c.pop_back();
    return c;
}
```

### 4除法

```c++
// 高精除低精
vector<int> div(vector<int> &a,int &b,int &r){
    vector<int> c;
    r=0;
    for(int i=a.size()-1;i>=0;i--){
        r=r*10+a[i];
        c.push_back(r/b);
        r%=b;
    }
    reverse(c.begin(),c.end());
    while(c.size()>1 && c.back()==0) c.pop_back();//去除前导零
    return c;
}
```



## 前缀和差分

***

$$
S[i]=\sum_{j=1}^{i}A[j]
$$



### 1一维前缀和

```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int M=1e5+10;
int a[M],b[M];
int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) b[i]=a[i]+b[i-1];
    while(m--){
        int l,r;
        scanf("%d%d",&l,&r);
        printf("%d\n",b[r]-b[l-1]);
    }
}
```

### 2二维前缀和

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int M=1e3+10;
int a[M][M],b[M][M];
int n,m,q,x1,y1,x2,y2;

int main(){
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];
    while(q--){
        scanf("%d%d%d%d",&x1,&y1,&x2,&y2);
        printf("%d\n",b[x2][y2]-b[x1-1][y2]-b[x2][y1-1]+b[x1-1][y1-1]);
    }
}
```

### 3一维差分

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int M=1e5+10;
int a[M],b[M];
int n,m;
int l,r,c;

void in(int l,int r,int c){//插入
    b[l]+=c;
    b[r+1]-=c;
}

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++) scanf("%d",&a[i]);
    for(int i=1;i<=n;i++) b[i]=a[i]-a[i-1];//构造差分数组
    for(int i=1;i<=m;i++){
        scanf("%d%d%d",&l,&r,&c);
        in(l,r,c);
    }
    for(int i=1;i<=n;i++) b[i]=b[i]+b[i-1];//还原数组
    for(int i=1;i<=n;i++) printf("%d ",b[i]);
}   
```

### 4二维差分

```c++
#include<iostream>
#include<cstdio>

using namespace std;

const int M=1000+10;
int n,m,q;
int a[M][M],s[M][M];
int x1,y1,x2,y2,c;

void in(int x1,int y1,int x2,int y2,int c){//插入
    s[x1][y1]+=c;
    s[x2+1][y1]-=c;
    s[x1][y2+1]-=c;
    s[x2+1][y2+1]+=c;
}

int main(){
    scanf("%d%d%d",&n,&m,&q);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            scanf("%d",&a[i][j]);
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            in(i,j,i,j,a[i][j]);//构造
    for(int i=1;i<=q;i++){
        scanf("%d%d%d%d%d",&x1,&y1,&x2,&y2,&c);
        in(x1,y1,x2,y2,c);
    }
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];//还原
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++){
            printf("%d ",s[i][j]);
            if(j==m) puts("");
        }
}
```



## 双指针算法

***

```c++
for (int i = 0, j = 0; i < n; i ++ ) {
    while (j < i && check(i, j)) j ++ ;
    // 具体问题的逻辑
}
```

常见问题分类：
* `(1)` 对于一个序列，用两个指针维护一段区间
* `(2)` 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作



## 离散化与逆序对

***

### 1哈希

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <unordered_map>

using namespace std;

typedef long long LL;

const int N = 5e5 + 10;
int c[N], n;
int a[N], b[N];
unordered_map<int, int> m;

int lowbit(int x) {
    return x & -x;
}

void add(int x, int v) {
    for (int i = x; i < N; i += lowbit(i))
        c[i] += v;
}

int query(int x) {
    int res = 0;
    for (int i = x; i; i -= lowbit(i))
        res += c[i];
    return res;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++ i) 
        scanf("%d", &a[i]), b[i] = a[i];
    sort(b + 1, b + 1 + n);
    int cnt = 0;
    for (int i = 1, j = 1; i <= n; ++ i) {
        while (j <= n && b[j] == b[i]) ++ j;
        m[b[i]] = ++ cnt;
        i = j - 1;
    }
    for (int i = 1; i <= n; ++ i)
        a[i] = m[a[i]];
    LL ans = 0;
    for (int i = 1; i <= n; ++ i) {
        add(a[i], 1);
        ans += i - query(a[i]);
    }
    cout << ans << endl;
}
```

### 2二分

```cpp
sort(b + 1, b + 1 + n);
int k = unique(b + 1, b + 1 + n) - b - 1;
for (int i = 1; i <= n; ++ i)
    a[i] = lower_bound(b + 1, b + 1 + k, a[i]) - b;
```



## 文件读写

***

```c++
// #include <cstdlib>
// freopen("P2058_2.in", "r", stdin);
// freopen("my_ans.out", "w", stdout);
// fclose(stdin);
// fclose(stdout);
```



## 快读

***

1cin加速: `cin.tie(0)->sync_with_stdio(0)`

根据个人评测经验，这种方法会比 `scanf()` 还要快

2使用 `getchar()`

```cpp
template<typename T> void read(T &x) {
    char ch = getchar(); bool flag = 0; x = 0;
    for (; ch < '0' || ch > '9'; ch = getchar())
        flag |= (ch == '-');
    for (; ch >= '0' && ch <= '9'; ch = getchar())
        x = (x << 1) + (x << 3) + ch - '0';
    if (flag) x = -x;
}
```

3将字符先读到 `buff` 数组中再从 `buff` 中读入

```cpp
inline char GET_CHAR() {
    static char buf[maxn], *p1 = buf, *p2 = buf;
    return p1 == p2 && (p2 = (p1 = buf) + 
        fread(buf, 1, maxn, stdin), p1 == p2) ? EOF: *p1 ++;
}

template<class T> inline void read(T &x) {
    x = 0; int f = 0; char ch = GET_CHAR();
    for (; ch < '0' || ch > '9'; ch = GET_CHAR()) flag |= (ch == '-');
    for (; ch >= '0' && ch <= '9'; ch = GET_CHAR()) x = (x << 1) + (x << 3) + (ch ^ 48);
    x = f ? -x: x;
}
```

