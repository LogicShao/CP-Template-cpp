## 背包问题

[背包九讲的出处](https://github.com/tianyicui/pack)，[y总亲讲 DP](https://www.bilibili.com/video/BV1qt411Z7nE?spm_id_from=333.999.0.0) ，有兴趣的可以看一下

**注意：背包不一定要装满**

### 闫式 DP 分析法

以 01 背包为例

### 01背包问题

**每件物品最多可以选一次**

#### 分析

| 起点     | $i\in [0,m]$，$f[0][i]=0$               |
| -------- | --------------------------------------- |
| 转移方程 | $f(i,j)=max(f(i-1,j),f(i-1,j-v_i)+w_i)$ |
| 终点     | $f(n,m)$                                |

#### code

* 朴素版本

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = 0; j <= m; ++ j) {
        f[i][j] = f[i - 1][j];
        if (v[i] <= j) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
    }

printf("%d", f[n][m]);
```

* 滚动数组优化

$f(i,j)$ 的计算只用到了 $f(i-1,j)$，所以可以用**滚动数组**优化

```cpp
int f[2][N];

for (int i = 1; i <= n; ++ i) {
    int now = i & 1, last = now ^ 1;
    for (int j = 0; j <= m; ++ j)  {
        f[now][j] = f[last][j];
        if (v[i] <= j) f[now][j] = max(f[now][j], f[last][j - v[i]] + w[i]);
    }
}

printf("%d", f[n & 1][m]);
```

* 优化为一维

我们发现转移方程中 $j-v_i<j$ 也就是说如果我们从后向前转移就不会有**后效性**

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = m; j >= v[i]; -- j)
        f[j] = max(f[j], f[j - v[i]] + w[i]);

printf("%d", f[m]);
```



### 完全背包

**每个物品可以选无限个**

#### 分析

| 起点     | $f(0,j)=0$                                                   |
| -------- | ------------------------------------------------------------ |
| 转移方程 | $ f(i,j) = Max_{k=0}^{v_i\times k\le j}f(i - 1, j - {v _ i} \times k) + {w _ i} \times k $ |
| 终点     | $f(n,m)$                                                     |

#### code

* 朴素版本

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = 0; j <= m; ++ j)
        for (int k = 0; k * v[i] <= j; ++ k)
            f[i][j] = max(f[i][j], f[i- 1][j - k * v[i]] + k * w[i]);

cout << f[n][m] << endl;
```

* 优化

我们发现：
$$
f(i,j)=Max_{k=0}^{k\times v_i\le j}f(i-1,j-k\times v_i)+k\times w_i
$$

而：
$$
f(i,j-v_i)=Max_{k=0}^{k\times v_i\le j-v_i}f(i-1,j-(k+1)\times v_i)+k\times w_i
$$

所以有：
$
f(i,j)=Max(f(i-1,j),f(i,j-v_i)+w_i)
$

如果再加上以上所说的一维优化就有：


```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = v[i]; j <= m; ++ j)
        f[j] = max(f[j], f[j - v[i]] + w[i]);

cout << f[m] << endl;
```

PS: 以前只是将其理解为**顺序遍历,一种物品会被"取"好多次**，但是现在发现原来可以从数学角度证明。



### 多重背包

**每个物品只能选有限个**

#### 分析

| 起点     | $f(0,j)=0$                                               |
| -------- | -------------------------------------------------------- |
| 转移方程 | $f(i,j)=Max_{k=0}^{s_i}f(i-1,j-v_i\times k)+w_i\times k$ |
| 终点     | $f(n,m)$                                                 |

#### code

* 朴素版本

```cpp
for (int i = 1; i <= n; ++ i)
    for (int j = 0; j <= m; ++ j)
        for (int k = 0; k <= s[i] && k * v[i] <= j; ++ k)
            f[i][j] = max(f[i][j], f[i - 1][j - k * v[i]] + w[i] * k);

cout << f[n][m] << endl;
```

* 二进制优化

证明：将一个正整数 $s$ 拆分为整数 $1,2,4,...,2^k,c$ ，可以表示出 $[0,s]$ 中的任意整数

其中：$\sum_{i=0}^k2^i+c=s$ ，这里要使得 $k$ 最大

根据[倍增](https://oi-wiki.org/basic/binary-lifting/#2)的思想 $1,2,4,...,2^k$ 可以表示 $[0,2^{k+1}-1]$ 中的任意整数

我们让其加上 $c$ 就有：原拆分可以表示 $[c,2^{k+1}-1+c]$ 中的任意整数

即证明：$[0,2^{k+1}-1]\cup[c,s]=[0,s]$

显然：$c<2^{k+1}$

所以原命题成立。

证毕。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;
const int N = 2010;
int f[N];
struct good { int v, w; };
int main() {
    int n, m;
    vector<good> goods;
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i) {
        int v, w, s;
        scanf("%d%d%d", &v, &w, &s);
        for (int k = 1; k <= s; s -= k, k <<= 1)
            goods.push_back({k * v, k * w});
        if (s) goods.push_back({s * v, s * w});
    }
    for (auto [v, w]: goods)
        for (int j = m; j >= v; -- j)
            f[j] = max(f[j], f[j - v] + w);
    cout << f[m] << endl;
}
```



### 分组背包

每组物品有若干个，同一组内的物品最多只能选一个。

#### 分析

| 起点     | $f(0,j)=0$                                                   |
| -------- | ------------------------------------------------------------ |
| 转移方程 | $f(i,j)=Max(f(i-1,j),Max_{k=1}^{s_i}f(i-1,j-v_{i,k})+w_{i,k})$ |
| 终点     | $f(n,m)$                                                     |

#### code

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 110;
int n, m;
int v[N][N], w[N][N], s[N];
int f[N];
int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++ i) {
        scanf("%d", s + i);
        for (int j = 1; j <= s[i]; ++ j) scanf("%d%d", &v[i][j], &w[i][j]);
    }
    for (int i = 1; i <= n; ++ i)
        for (int j = m; j; -- j)
            for (int k = 1; k <= s[i]; ++ k)
                if (v[i][k] <= j)
                    f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
    printf("%d", f[m]);
}
```